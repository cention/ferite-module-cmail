uses "cmail.lib";
uses "array";
uses "regexp";
uses "string";
uses "iconv";
uses "filesystem";
uses "console";

module-header {
	#include "imap_utility.h"
	#include <imap/linkage.h>
	#include <imap/c-client.h>

	extern char *curhst;
	extern char *curusr;
	extern char *global_pwd;
	#define SelfObj ((MAILSTREAM*)(self->odata))
	
	extern FeriteScript *output_script;
	extern FeriteObject *output_closure;
}

module-init {
	curhst = NULL;
	curusr = NULL;
	global_pwd = NULL;
	output_closure = NULL;
	output_script = NULL;
	
	ssl_onceonlyinit();
}

/**
 * @namespace Mail
 * @brief     The holding namespace for Mail related tools
 * @example <code>
uses "cmail";
<nl/>uses "console";
<nl/>
<nl/>function fetchmail( string host, string username, string password ) {
<nl/><tab/>object connection = new Mail.Connection();
<nl/>
<nl/><tab/>if( connection.openMailbox( "{$host:993/imap/ssl/novalidate-cert/user=\"$username\"}", password) ) {
<nl/><tab/><tab/>number count = connection.messageCount();
<nl/><tab/><tab/>for( number i = 1; i <= count; i++ ) {
<nl/><tab/><tab/><tab/>object message = connection.messageAtIndex(i);
<nl/><tab/><tab/><tab/>Console.println("Got message: ${message.getSubject()}: ${message.toText()}");
<nl/><tab/><tab/>}
<nl/><tab/>}
<nl/>}
<nl/>
<nl/>fetchmail( "mail.myisp.com", "username", "password" );</code>
 */
namespace modifies Mail {
	
	final number OUTPUT_DEBUG = 1;
	final number OUTPUT_NORMAL = 2;
	final number OUTPUT_WARNING = 3;
	final number OUTPUT_ERROR = 4;
	
	function outputTypeToString( number type ) {
		switch(type) {
			case Mail.OUTPUT_DEBUG: return 'debug';
			case Mail.OUTPUT_NORMAL: return 'normal';
			case Mail.OUTPUT_WARNING: return 'warning';
			case Mail.OUTPUT_ERROR: return 'error';
			default:
				return '';
		}
		return '';
	}
	native function registerOutput( object output ) {
		output_script = script;
		if( output_closure ) {
			FDECREF(output_closure);
		}
		output_closure = output;
		FINCREF(output_closure);
	}
	native function output( number type, string text ) {
		output_printf( (int)type, text->data );
	}

	/**
	 * @variable defaultEncodingTarget
	 * @type     string
	 * @brief    The default encoding required for email contents. The Mail module will convert all messages to 
                 a default encoding to make handling of messages easier. The default and recommended default encoding
                 is UTF-8. 
	 */
	string defaultEncodingTarget = "UTF-8";
	array  defaultEncodingTargetVariants;
	
	/**
	 * @variable defaultEncodingSource
	 * @type     string
	 * @brief    The default encoding assumed when emails do not provide a default encoding.
	 */
	string defaultEncodingSource = "ISO-8859-1";
	
	/**
	 * @function convertToDefaultEncodingFrom
	 * @declaration function convertToDefaultEncodingFrom( string content, string type )
	 * @brief Convert a given string from a type to the default encoding
	 * @param string content The content to convert
	 * @param string type The source character set type
	 * @return The converted string on success
	 */
	function requestedTypeIsTarget( string type ) {
		return (type.toLower() == .defaultEncodingTarget.toLower()) or (.defaultEncodingTargetVariants.valueExists(type.toUpper()));
	}
	function convertToDefaultEncodingFrom( string content, string type ) {
		object convertor = null;

		if( .requestedTypeIsTarget(type) and not content.isUTF8() ) {
			// Special case, if it claims to be UTF-8 and there is no UTF-8 characters within the code, we try to convert it
			// Sometimes emails will claim UTF-8, but will actually encode into ISO-8859-1
			Mail.output(Mail.OUTPUT_NORMAL,"Invoking special case: claims UTF-8, no UTF-8 found, attempting convert from ${.defaultEncodingSource}");
			type = .defaultEncodingSource;
		}

		if( type == 'IBM01142' ) {
			type = 'CP01142';
		} else if( type and ( type.toLower() == 'ks_c_5601-1987' or type.toLower() == 'ks_c_5601-1989' )) {
			type = 'EUC-KR';
		}

		if( not type or type.toLower() == 'x-unknown' ) {
			Mail.output(Mail.OUTPUT_NORMAL,"module.mail: No charset requested, defaulting to ${.defaultEncodingSource}");
			type = .defaultEncodingSource;
		}
		
		monitor {
			convertor = new iconv.Convertor(Mail.defaultEncodingTarget, type);
		} handle {
			Mail.output(Mail.OUTPUT_WARNING,"Could not create converter from $type to ${Mail.defaultEncodingTarget}, attempting convert from ${.defaultEncodingSource}");
			type = .defaultEncodingSource;
			monitor {
				convertor = new iconv.Convertor(Mail.defaultEncodingTarget, type);
			} handle {
				Mail.output(Mail.OUTPUT_ERROR,"Could not create converter from $type to ${Mail.defaultEncodingTarget}");
				convertor = null; //no convertion beacasue we have no convertor..... :/
			}
		}
		
		if( not (.requestedTypeIsTarget(type)) and convertor ) {
			monitor {
				return convertor.convert(content);
			} handle {
				if( [ 'us-ascii' ].valueExists(type.toLower()) ) {
					Mail.output(Mail.OUTPUT_WARNING,"module.module: $type failed, trying ${.defaultEncodingSource}");
					return .convertToDefaultEncodingFrom( content, .defaultEncodingSource );
				}
				Mail.output(Mail.OUTPUT_ERROR,"module.mail: Error Converting from $type to ${Mail.defaultEncodingTarget}");
				return content;
			}
		}
		return content;
	}

	string searchDecoding = '[=?]+(iso-.*?|utf-8|koi8-r|windows-.*?|x-unknown|us-ascii)[?](.)[?](.*?)\?=';
	string search_eurkr = '[=?]+(ks_c_5601-.+?)[?](.)[?](.*?)\?=';

	/**
	 * @function canDecodeISOString
	 * @declaration function canDecodeISOString( string str )
	 * @brief Check to see if a given string can be converted from the ISO email format to plain text
	 * @param string str The string to check
	 * @return true if the string can be fixed, false otherwise
	 */
	function canDecodeISOString( string str ) {
		object o = new Regexp(.searchDecoding, "i");
		object o2 = new Regexp( '(iso-.*?)[\']{2}(.*)', "i" );
		object o3 = new Regexp(.search_eurkr, "i");

		str = Regexp.replaceAll( '\n', str, '' );
		if(o.match(str) or o2.match(str) or o3.match(str)) {
			return true;
		}
		return false;
	}
	/**
	 * @function decodeISOString
	 * @declaration function decodeISOString( string str )
	 * @brief Convert a string from the ISO format to a plain text string
	 * @param string str The string to convert
	 * @return The converted string
	 */
	function decodeISOString( string str ) {
		string nstr;
		object o = new Regexp(.searchDecoding, "i");
		object o2 = new Regexp( '(iso-.*?)[\']{2}(.*)', "i" );
		object o3 = new Regexp(.search_eurkr, "i");
		number currentIndex = 0;

		str = Regexp.replaceAll( '\n', str, '' );
		if( o.match( str ) ) {
			string charset;
			str = Regexp.replaceAll( ' ', str, '' );
			str = Regexp.replaceAll( '_', str, ' ' );
			o.matchAll( str ) using ( match ) {
				if( match.span()[0] != currentIndex )
					nstr += str[currentIndex..(match.span()[0]-1)];

				if( not charset )
					charset = match.capture(0);

				if( String.compareNoCase(match.capture(1), "q") )
					nstr += Mail.Connection.qprint( match.capture(2) );
				else if( String.compareNoCase( match.capture(1), "b") )
					nstr += Mail.Connection.base64( match.capture(2) );
				else
					nstr += match.capture(2);

				currentIndex = match.span()[1];
			};

			if( currentIndex < String.length(str) )
				nstr += str[currentIndex..];

			return .convertToDefaultEncodingFrom(nstr, charset);
		}
		else if( o2.match( str ) ) {
			object match = null;
			str = Regexp.replaceAll( '_', str, ' ' );
			match = o2.match( str );
			str = Regexp.replaceAll( '%', str, '=' );
			return .convertToDefaultEncodingFrom(Mail.Connection.qprint(match.capture(1)),match.capture(0));
		}
		else if(o3.match(str)) {
			string charset;
			// loop all the pattern with =?xx?x?xxx?=
			// some email headers has multiple of this pattern in
			// one header
			o3.matchAll(str) using (match) {
				// get the first charset
				if(not charset) {
					charset = match.capture(0);
				}
				// get whatever prefix the match
				if(match.span()[0] != currentIndex)
					nstr += str[currentIndex..(match.span()[0]-1)];
				// decode according to content transfer encoding
				if(String.compareNoCase(match.capture(1), "q"))
					nstr += Mail.Connection.qprint(match.capture(2));
				else if(String.compareNoCase( match.capture(1), "b"))
					nstr += Mail.Connection.base64(match.capture(2));
				else
					nstr += match.capture(2);
				currentIndex = match.span()[1];
			};
			if(currentIndex < String.length(str))
				nstr += str[currentIndex..];
			nstr = Regexp.replaceAll('_', nstr, ' ');
			return .convertToDefaultEncodingFrom(nstr, charset);
		}
		return str;
	}
	/**
	 * @function encodeISOString
	 * @declaration function encodeISOString( string str )
	 * @brief ISO encode a given string, this function assumes the strings character set is that of the default target
	 * @param string str The string to encode
	 * @return Encoded string
	 */
	function encodeISOString( string str ) {
		return .encodeISOString( str, .defaultEncodingTarget );
	}
	/**
	 * @function encodeISOString
	 * @declaration function encodeISOString( string str, string charset )
	 * @brief Encode a string from a given character set into an ISO format
	 * @param string str The string to encode
	 * @param string charset The character set to assume the string came from
	 * @return The UTF-8 encoded ISO string.
	 */
	function encodeISOString( string str, string charset ) {
		if( not .canDecodeISOString(str) and not Regexp.match('^[A-Za-z0-9.? -:]+$', str ) ) {
			string real_str = str;
			string enc_str = '';
			if( charset != .defaultEncodingTarget ) {
				real_str = .convertToDefaultEncodingFrom( str, charset );
			}
			real_str.utf8Blocks(1).each() using ( block ) {
				enc_str += Mail.Connection.bit8( block );
			};		
		    enc_str = Regexp.replaceAll( '\ ', enc_str, '_' );
		    enc_str = Regexp.replaceAll( '\?', enc_str, '=3F' );
			if( real_str )
			    return "=?${.defaultEncodingTarget}?Q?$enc_str?=";
			return "";
		} 
		return str;
	}
	/**
	 * @function stripHTML
	 * @declaration function stripHTML( string html )
	 * @brief Strip the HTML from a given string
	 * @description This function will convert various entities to plain text versions, remove tags and replaces line breaks with new lines.
	 * @param string html The string to strip
	 * @return A stripped string
	 */
	function stripHTML( string html ) {
	    return Mail.HTML.stripHTML(html);
	}
	function stripTags( string html ) {
		return Mail.HTML.stripTags(html);
	}

	
	function truncateHeaderLine( string line, number extra ) {
		number maxLength = (998 - String.length("=?${.defaultEncodingTarget}?Q??=") - extra);
		if( line.length() > maxLength ) {
			string newLine;
			while( ( newLine.length() + line.nextCharacterLength() ) * 3 <= maxLength ) {
				newLine += line.nextCharacter();
				line = line[line.nextCharacterLength()..];
			}
			return newLine;
		}
		return line;
	}
	
	/**
	 * @class Connection
	 * @brief An instance of this class is required to connect to a mail server
	 */
	class Connection
	{
		string _errstr;
		string account_type; 

		native function constructor() {
			self->odata = NULL;
			//set timeout.
			mail_parameters(NIL, SET_OPENTIMEOUT, (void *)120);
			mail_parameters(NIL, SET_READTIMEOUT, (void *)120);
			mail_parameters(NIL, SET_WRITETIMEOUT, (void *)120);
			mail_parameters(NIL, SET_CLOSETIMEOUT, (void *)120);
			//set number of login tries.
			mail_parameters(NIL, SET_MAXLOGINTRIALS, (void *)2);

			//mail_parameters(NIL, SET_TRYSSLFIRST, (void *)T);
			//mail_parameters(NIL, SET_IMAPTRYSSL, (void *)NIL);
		}
		
		function setAccountType(string type) 
		    self.account_type = type;

		function errstr() {
			return ._errstr;
		}

		/**
		 * @function qprint
		 * @declaration static native function qprint( string str )
		 * @brief Convert a normal string into a quoted printable string
		 * @param string str The string to convert
		 * @return A quoted printable version of the string
		 * @static
		 */
		static native function qprint( string str ) {
			FeriteVariable *v;	
			char *nstr;
			unsigned long len2;
			//fprintf(stderr, "str = %s, len = %d", str->data, str->length);
			nstr = rfc822_qprint( str->data , str->length, &len2 );
			//fprintf(stderr, "New string=%s len2 = %d", nstr, len2);
			v = fe_new_str( "qprint", nstr, len2, FE_CHARSET_DEFAULT );
			FE_RETURN_VAR( v );
		}

		/**
		 * @function base64
		 * @declaration static native function base64( string str )
		 * @brief Base64 encode a string
		 * @param string str The string to base64 encode
		 * @return The string in base64 format
		 * @static
		 */
		static native function base64( string str ) {
			FeriteVariable *v;	
			char *nstr;
			unsigned long len2;
			//fprintf(stderr, "str = %s, len = %d", str->data, str->length);
			nstr = rfc822_base64( str->data , str->length, &len2 );
			//fprintf(stderr, "New string=%s len2 = %d", nstr, len2);
			v = fe_new_str( "base64", nstr, len2, FE_CHARSET_DEFAULT );
			FE_RETURN_VAR( v );
		}
		/**
		 * @function bit8
		 * @declaration static native function bit8( string str )
		 * @brief Using the RFC822 8bit specification, convert a string to be 8bit safe.
		 * @param string str The string to convert
		 * @return 8bit safe string
		 * @static
		 */
		static native function bit8( string str ) {
			FeriteVariable *v;	
			char *nstr;
			unsigned long len2;
			//fprintf(stderr, "str = %s, len = %d", str->data, str->length);
			nstr = rfc822_8bit( str->data , str->length, &len2 );
			//fprintf(stderr, "New string=%s len2 = %d", nstr, len2);
			v = fe_new_str( "8bit", nstr, len2, FE_CHARSET_DEFAULT );
			FE_RETURN_VAR( v );
		}

		/**
		 * @function openMailbox
		 * @declaration function openMailbox( string proto, string host, number port, string username, string password )
		 * @brief Connect and open the default mailbox readed for reading
		 * @param string proto The protocol (imap or pop3)
		 * @param string host The host to connect to
		 * @param number port The port to use (default pop3: 110, imap: 143 and imaps: 993)
		 * @param string username The username to log in with
		 * @param string password The password to use
		 * @return true if connection successful, false otherwise
		 */
		function openMailbox( string proto, string host, number port, string username, string password ) {
			return .openSpecificMailbox( proto, host, port, username, password, "INBOX" );
		}
		/**
		 * @function openSpecificMailbox
		 * @declaration function openSpecificMailbox( string proto, string host, number port, string username, string password, string mailbox )
		 * @brief Connect to a server and open the specifically named mailbox for reading. If you supply the name "INBOX", the mail server will use the default inbox for the user.
		 * @param string proto The protocol to use (imap/pop3)
		 * @param string host The host to connec to 
		 * @param number port The port to use (default pop3: 110, imap: 143 and imaps: 993)
		 * @param string username The user to log in with
		 * @param string password The passowrd to use
		 * @param string mailbox The mailbox to connect to
		 * @return true if connection successful, false otherwise
		 */
		function openSpecificMailbox( string proto, string host, number port, string username, string password, string mailbox ) {
			return .openMailboxURI( "{$host:$port/$proto/user=\"$username\"}$mailbox", password );
		}
		/**
		 * @function openMailboxURI
		 * @declaration native function openMailboxURI( string mbox, string passwd )
		 * @brief Connect and open a given mailbox identifier
		 * @description The mbox identifier can be made up of the following values:<nl/>
		 * <nl/>
		 * The mbox part, which is enclosed in '{' and '}', consists of the servers name or ip address, an optional port (prefixed by ':'), and an optional protocol specification (prefixed by '/'). All names which start with { are remote names, and are in the form "{" remote_system_name [":" port] [flags] "}" [mailbox_name] where:<nl/>
		 * <nl/>
		 * <emphasis>remote_system_name</emphasis> - Internet domain name or bracketed IP address of server.<nl/>
		 * <emphasis>port</emphasis> - optional TCP port number, default is the default port for that service<nl/>
		 * <emphasis>flags</emphasis> - optional flags, see following details.<nl/>
		 * <emphasis>mailbox_name</emphasis> - remote mailbox name, default is INBOX<nl/>
		 * <nl/>
		 * <strong>/service=service</strong> : mailbox access service, default is "imap"<nl/>
		 * <strong>/user=user</strong> : remote user name for login on the server<nl/>
		 * <strong>/authuser=user</strong> : remote authentication user; if specified this is the user name whose password is used (e.g. administrator)<nl/>
		 * <strong>/anonymous</strong> : remote access as anonymous user<nl/>
		 * <strong>/debug</strong> : record protocol telemetry in application's debug log<nl/>
		 * <strong>/secure</strong> : do not transmit a plaintext password over the network<nl/>
		 * <strong>/imap, /imap2, /imap2bis, /imap4, /imap4rev1</strong> : equivalent to /service=imap<nl/>
		 * <strong>/pop3</strong> : equivalent to /service=pop3<nl/>
		 * <strong>/nntp</strong> :equivalent to /service=nntp<nl/>
		 * <strong>/norsh</strong> : do not use rsh or ssh to establish a preauthenticated IMAP session<nl/>
		 * <strong>/ssl</strong> :use the Secure Socket Layer to encrypt the session<nl/>
		 * <strong>/validate-cert</strong> : validate certificates from TLS/SSL server (this is the default behavior)<nl/>
		 * <strong>/novalidate-cert</strong> : do not validate certificates from TLS/SSL server, needed if server uses self-signed certificates<nl/>
		 * <strong>/tls</strong> : force use of start-TLS to encrypt the session, and reject connection to servers that do not support it<nl/>
		 * <strong>/notls</strong> : do not do start-TLS to encrypt the session, even with servers that support it<nl/>
		 * <strong>/readonly</strong> :request read-only mailbox open (IMAP only; ignored on NNTP, and an error with SMTP and POP3)<nl/>
		 * @example openMailbox("{host:993/imap/ssl/novalidate-cert/user="username"}INBOX", "password")
		 * @param string mbox A description as above.
		 * @param string passwd The password
		 * @return rue if connection successful, false otherwise
		 */
		native function openMailboxURI( string mbox, string passwd ) {
			char data[1024];
#include "imap/linkage.c" 
			global_pwd = passwd->data;

			self->odata = mail_open( SelfObj, mbox->data, 0);
			if( SelfObj == NULL ) {
				set_error_string( script, self, "Unable to open mailbox" );
				FE_RETURN_FALSE;
			}
			FE_RETURN_TRUE;
		}

		/**
		 * @function closeMailbox
		 * @declaration native function closeMailbox( )
		 * @brief Close the mailbox if it is open
		 * @return true if the mail box has been closed, false otherwise
		 */
		native function closeMailbox( ) {
			if( SelfObj ) {
				mail_close( SelfObj );
				self->odata = NULL;
				FE_RETURN_TRUE;
			}
			FE_RETURN_FALSE;
		}
		
		/**
		 * @function messageCount
		 * @declaration native function messageCount( )
		 * @brief Read the mailbox and return the number of messages within the mail box.
		 * @return Message count as a number
		 */
		native function messageCount( ) {
			FE_RETURN_LONG( SelfObj->nmsgs );
		}

		/**
		 * @function messageAtIndex
		 * @declaration native function messageAtIndex( number n )
		 * @brief Fetch an entire message at a given index.
		 * @warning All indicies are not like normal array indicies, the count starts at 1 and ends at .messageCount()
		 * @param number n The index to fetch
		 * @return A Mail.Message object on success, null otherwise
		 */
		native function messageAtIndex( number n ) {
			ENVELOPE *env = NULL;
			BODY *body = NULL;
			FeriteVariable *header = NULL, *content = NULL, *mail = NULL;
			
			if( (long)n < 1 || (long)n > SelfObj->nmsgs ) {
				set_error_string( script, self, "Message number out of bounds" );
				FE_RETURN_NULL_OBJECT;
			}

			env = mail_fetchstructure_full( SelfObj, n, &body, NIL );

			header = create_ferite_header_object( script, env );
			if( header == NULL ) {
				set_error_string( script, self, "Couldn't create header" );
				FE_RETURN_NULL_OBJECT;
			}

			content = create_ferite_content_object( script, SelfObj, body, (long)n, NULL );
			if( content == NULL ) {
				set_error_string( script, self, "Couldn't create body" );
				FE_RETURN_NULL_OBJECT;
			}

			if( header == NULL || body == NULL ) {
				FE_RETURN_NULL_OBJECT;
			}
			mail = create_ferite_mail_object( script, header, content );
			if( mail == NULL ) {
				set_error_string( script, self, "Internal error" );
				FE_RETURN_NULL_OBJECT;
			} else {
				unsigned long header_length = 0, body_length = 0;
				char *raw_header = mail_fetchheader_full( SelfObj, n, NULL, &header_length, 0 );
				char *raw_body = mail_fetchtext_full( SelfObj, n, &body_length, 0 );
				FeriteVariable *rawheaderv = ferite_object_get_var( script, VAO(mail), "rawHeader" );
				FeriteVariable *rawcontentv = ferite_object_get_var( script, VAO(mail), "rawContent" );
				ferite_str_set( script, VAS(rawheaderv), raw_header, header_length, FE_CHARSET_DEFAULT );
				ferite_str_set( script, VAS(rawcontentv), raw_body, body_length, FE_CHARSET_DEFAULT );
			}
			
			FE_RETURN_VAR( mail );
		}
		/**
		 * @function messageHeaderAtIndex
		 * @declaration native function messageHeaderAtIndex( number n )
		 * @brief Fetch just the message header at a given index.
		 * @warning All indicies are not like normal array indicies, the count starts at 1 and ends at .messageCount()
		 * @param number n The index to fetch
		 * @return A Mail.Message object on success with the header variable set, null otherwise
		 */
		native function messageHeaderAtIndex( number n ) {
			ENVELOPE *env = NULL;
			BODY *body = NULL;
			FeriteVariable *header = NULL, *content = NULL, *mail = NULL;
			unsigned long length = 0;
			
			if( (long)n < 1 || (long)n > SelfObj->nmsgs ) {
				set_error_string( script, self, "Message number out of bounds" );
				FE_RETURN_NULL_OBJECT;
			}

			env = mail_fetchenvelope( SelfObj, n );
			header = create_ferite_header_object( script, env );
			if( header == NULL ) {
				set_error_string( script, self, "Couldn't create header" );
				FE_RETURN_NULL_OBJECT;
			}
			mail = create_ferite_mail_object( script, header, content );
			if( mail == NULL ) {
				set_error_string( script, self, "Internal error" );
				FE_RETURN_NULL_OBJECT;
			} else {
				char *raw_header = mail_fetchheader_full( SelfObj, n, NULL, &length, 0 );
				FeriteVariable *rawheaderv = ferite_object_get_var( script, VAO(mail), "rawHeader" );
				ferite_str_set( script, VAS(rawheaderv), raw_header, length, FE_CHARSET_DEFAULT );
			}
			
			FE_RETURN_VAR( mail );
		}

		/**
		 * @function sendMessage
		 * @declaration native function sendMessage( string server, object mailet )
		 * @brief With a given Mail.Message object, send the email using the supplied SMTP server
		 * @warning This function will automatically ISO encode headers, names and the subject of the email if it needs to be done.
					The change will not be reflected when the function has returned. This means you need not worry about correct ISO
					string escaping for the various parts of the email - just assign strings and away you go.
		 * @param string server The server to send the message with
		 * @param object mailet The Mail.Message object to send
		 * @return true on success, fales otherwise
		 */
		function sendMessage( string server, object mail ) {
			return .sendMessage( server, '', '', false, false, mail );
		}
		/**
		 * @function sendMessage
		 * @declaration function sendMessage( string _server, string usernane, string password, boolean ssl, object mail )
		 * @brief With a given Mail.Message object, send the email using the supplied SMTP server paying attention to the authentication details provided
		 * @warning This function will automatically ISO encode headers, names and the subject of the email if it needs to be done.
					The change will not be reflected when the function has returned. This means you need not worry about correct ISO
					string escaping for the various parts of the email - just assign strings and away you go.
		 * @param string _server The SMTP host to connect to
		 * @param string usernane The username to use, leave blank if you do not want authentication
		 * @param string password The password to use with the username name, leave blank if you do not want authentication
		 * @param boolean ssl Whether the connection should be done over SSL, false if SSL is not desired
		 * @param boolean tls Whether the connection should be done over TLS, false if TLS is not desired
		 * @param object mail The Mail.Message object to send
		 * @return true on success, false otherwise
		 */
		function sendMessage( string _server, string username, string password, boolean ssl, boolean tls, object mail ) {
			object old_header = mail.header;
			object new_header = old_header.duplicate();
			string new_subject = Mail.encodeISOString(Mail.truncateHeaderLine(Regexp.replaceAll('[\r\n]', old_header.subject, ' '), String.length("Subject: ")));
			string server = _server;
			boolean result = false;

			// Encode the headers
			mail.outgoingHeaders.map() using ( key, value ) {
				new_subject += "\r\n$key: ${Mail.encodeISOString(value)}";
			};
			new_header.subject = new_subject;
			// Check the encoding of names
			new_header.checkEncoding();
			// Swap out the old header
			mail.header = new_header;

			     if( ssl ) server += "/ssl/novalidate-cert";
			else if( tls ) server += "/tls/novalidate-cert";
			else           server += "/novalidate-cert";

			if( username ) server += "/user=$username";

			result = .__sendMessage( server, password, mail );
			// Bring back the old header
			mail.header = old_header;
			return result;
		}
		native function __sendMessage( string server, string password, object mailet ) {
			FeriteVariable *content = NULL, *header = NULL;
			ENVELOPE *env = NULL;
			BODY *body = NULL;
			SENDSTREAM *stream = NULL;
			char *hostlist[] = { server->data, NIL };

#include "imap/linkage.c"

			// Set the password
			global_pwd = password->data;
			
			header  = ferite_hash_get(script,mailet->variables->variables,"header");
			content = ferite_hash_get(script,mailet->variables->variables,"content");
			if(! ( header && content ) ) {
				printf("internal error\n");
				FE_RETURN_FALSE;
			}
			
			body = create_imap_content_object(script, content);
			if ( body == NULL ) {
				set_error_string( script, self, "Couldn't create body" );
				FE_RETURN_FALSE;
			}

			env = create_imap_envelope( script, header );
			if ( env == NULL ) {
				set_error_string( script, self, "Couldn't create header" );
				FE_RETURN_FALSE;
			}

			stream = smtp_open( hostlist, OP_DEBUG ); // SOP_TRYSSL
			
			if( stream == NULL ) {
				set_error_string( script, self,"Error opening SMTP stream" );
				FE_RETURN_FALSE;
			}
	
			if( smtp_mail( stream, "MAIL", env, body ) == NIL ) {
				set_error_string( script, self,"SMTP Error" );
				output_printf(4, stream->reply);
				FE_RETURN_FALSE;
			}
			smtp_close( stream );
			FE_RETURN_TRUE;
		}
		
		/**
		 * @function expungeMessages
		 * @declaration native function expungeMessages()
		 * @brief Expunge all messages flagge as being deleted 
		 */
		native function expungeMessages() {
			mail_expunge( SelfObj );
			FE_RETURN_TRUE;
		}

		/**
		 * @function flagMessageDeleted
		 * @declaration native function flagMessageDeleted( number n )
		 * @brief Flag a message at a given index to be deleted. Use expungeMessages() to actually remove all the messages.
		 * @warning All indicies are not like normal array indicies, the count starts at 1 and ends at .messageCount()
		 * @param number n The message index to be flagged
		 */
		native function flagMessageDeleted( number n ) {
			char str[9];
			if( n > 0 && n <= SelfObj->nmsgs ) { 
				sprintf (str,"%lu",(long)n);
				mail_setflag_full(SelfObj, str, "\\DELETED", NIL);
				FE_RETURN_TRUE;
			}
			FE_RETURN_FALSE;
		}

		/**
		 * @function flagMessageSeen
		 * @declaration native function flagMessageSeen( number n )
		 * @brief Flag a message at a given index as being seen.
		 * @warning All indicies are not like normal array indicies, the count starts at 1 and ends at .messageCount()
		 * @param number n The message index to be flagged
		 */
		native function flagMessageSeen( number n ) {
			char str[7];
			if( n > 0 && n <= SelfObj->nmsgs ) { 
				sprintf(str,"%lu",(long)n);
				mail_setflag_full(SelfObj,str,"\\SEEN", NIL);
				FE_RETURN_TRUE;
			}
			FE_RETURN_FALSE;
		}
		/**
		 * @function messageBeenSeen
		 * @declaration native function messageBeenSeen( number n )
		 * @brief Check to see if a message at a given index has been seen.
		 * @warning All indicies are not like normal array indicies, the count starts at 1 and ends at .messageCount()
		 * @param number n The message index to check
		 * @return true if the message has been seen, false otherwise.
		 */
		native function messageBeenSeen( number n ) {
		    MESSAGECACHE *elt;
		    if( n > 0 && n <= SelfObj->nmsgs ) {
				elt  = mail_elt(SelfObj, n);
				if( elt->seen ) { // elt->recent)
			    	FE_RETURN_TRUE;
				}
		    }
		    FE_RETURN_FALSE;
		}

		function setupSSLCert(string &_server, string username, string password, boolean ssl){
			_server = _server + (ssl ? "/ssl/novalidate-cert" : "/novalidate-cert/notls") + (username ? "/authuser=$username" : "");
		}

        native function getServerMaxMailSize(string server ) {
            SENDSTREAM *stream = NULL;
            NETMBX networkMailbox;
            char *hostlist[] = { server->data, NIL };
            long maxMailSize = -1;

			memset(&networkMailbox, '\0', sizeof(networkMailbox));
			stream = smtp_open( hostlist, FE_FALSE); 
            if( stream == NULL ) {
                set_error_string( script, self,"Error opening SMTP stream" );
                FE_RETURN_LONG( -2 );
            }

            smtp_ehlo( stream, "localhost", &networkMailbox );

            if(stream->protocol.esmtp.size.ok){
                maxMailSize = stream->protocol.esmtp.size.limit;
            }
			else{
				maxMailSize = -3;
			}

            smtp_close( stream );

            FE_RETURN_LONG( maxMailSize );
        }
	}
	/**
	 * @end
	 */

	
	/**
	 * @class Message
	 * @brief Every email is represented by a Mail.Message object
	 */
 	class Message
	{
		/**
		 * @variable header
		 * @type     object
		 * @brief    A variable of type Mail.MessageHeader
		 */
		object header;
		/**
		 * @variable content
		 * @type     object
		 * @brief    An object of either Mail.MessageMultiPart or Mail.MessagePart
		 * @static
		 */
		object content;

		/**
		 * @variable rawHeader
		 * @type     string
		 * @brief    The complete raw header for the message
		 */
		string rawHeader;
		/**
		 * @variable rawContent
		 * @type     string
		 * @brief    The complete raw content for the message
		 * @warning  Be careful using this variable, it could be multiple megabytes big which can be very slow to process.
		 */
		string rawContent;

		array extractedHeaders;
		/**
		 * @function extractIncomingHeaders
		 * @declaration function extractIncomingHeaders()
		 * @brief Extract the custom headers from the mail header and return a keyed array with the values
		 * @return The headers in an associative array
		 */
		function extractIncomingHeaders() {
			if( not .extractedHeaders ) {
				array s = String.dissect( Regexp.replaceAll("\r", .rawHeader, ""), "\n", 0 );
				string lastHeader;
				object m, r = new Regexp( '^([^:]+): (.*)' );
				s.each() using ( line ) {
					if( (m = r.match(line)) ) {
						lastHeader = m.capture(0);
						.extractedHeaders[lastHeader] = m.capture(1).trim(' ');
					} else {
						.extractedHeaders[lastHeader] += ' ' + line.trim(' ');
					}
				};
			}
			return .extractedHeaders;
		}
		
		array outgoingHeaders;
		/**
		 * @function setOutgoingHeader
		 * @declaration function setOutgoingHeader( string name, string value )
		 * @brief Set a custom out-going header to be added to the flags
		 * @param string name The name of the header, if unofficial prefix it with 'X-'
		 * @param string value The value of the header
		 */
		function setOutgoingHeader( string name, string value ) {
			.outgoingHeaders[name] = value;
		}
		
		function constructor(){
			self.header = new Mail.MessageHeader();
		}
		
		/**
		 * @function getSubject
		 * @declaration function getSubject()
		 * @brief Get the message subject. This function will make sure that the string returned has been processed.
		 * @return The subject
		 */
		function getSubject() {
			string subject = (.header.subject ? .header.subject : '');
			if( subject ){
				if( Mail.canDecodeISOString(subject) ) {
					subject = Mail.decodeISOString(subject);
				} else {
					if( not subject.isUTF8() ) {
						if( .content ) {
							subject = Mail.convertToDefaultEncodingFrom( subject, .guessMainCharacterSet() );
						} else {
							subject = Mail.convertToDefaultEncodingFrom( subject, '' );
						}
					}
				}
			}
			return subject;
		}
		/**
		 * @function guessMainCharacterSet
		 * @declaration function guessMainCharacterSet()
		 * @brief Guess, by looking at the message content, what the default character set of the incomming email was.
		 * @return The character set as a string.
		 */
		function guessMainCharacterSet() {
			return .content.characterSet();
		}
		/**
		 * @function attachmentList
		 * @declaration function attachmentList()
		 * @brief Fetch an array of Mail.MessagePart(s) that are attachments to the email
		 * @return An array of attachments.
		 */
		function attachmentList()
			return self.content.attachmentList();
			
		/**
		 * @function toText
		 * @declaration function toText()
		 * @brief The email as plain text. This will be a combination of the text/plain elements of the email.
		 * @description You may pass this function a closure that takes one parameter - the Mail.MessagePart object that represents an attachment. 
				The return from invoking this closure will be the content of the attachment in the email. This is useful when you desire custom anchors
				or other functionality in the place of an attachment. If you do not supply a closure, the system will place attachment anchors within the
				returned string, to retrieve these and do some processing, you need to use the function Mail.MessagePart.regexpForAttachmentAnchors 
				to obtain an object that can be used to match the anchors within the text.
		 * @return A string containing the message body
		 */
		function toText() {
			object attachmentDelivery = recipient();
			return self.content.toMessage( false, attachmentDelivery );
		}
		/**
		 * @function toHTML
		 * @declaration function toHTML()
		 * @brief The email as html. This will be a combination of the text/html elements of the email.
		 * @description You may pass this function a closure that takes one parameter - the Mail.MessagePart object that represents an attachment. 
				The return from invoking this closure will be the content of the attachment in the email. This is useful when you desire custom anchors
				or other functionality in the place of an attachment. If you do not supply a closure, the system will place attachment anchors within the
				returned string, to retrieve these and do some processing, you need to use the function Mail.MessagePart.regexpForAttachmentAnchors 
				to obtain an object that can be used to match the anchors within the text.
		 * @return The return values
		 */
		function toHTML() {
			object attachmentDelivery = recipient();
			return self.content.toMessage( true, attachmentDelivery );
		}
		/**
		 * @function hasTextVersion
		 * @declaration function hasTextVersion()
		 * @brief Check to see if the email has a text/plain part(s) to it.
		 * @return true if there is a text/plain block, false otherwise
		 */
		function hasTextVersion()
			return self.content.hasTextVersion();
		/**
		 * @function hasHTMLVersion
		 * @declaration function hasHTMLVersion()
		 * @brief Check to see if the email has a text/html part(s) to it.
		 * @return true if there is a text/html block, false otherwise
		 */
		function hasHTMLVersion()
			return self.content.hasHTMLVersion();
	}
	/**
	 * @end
	 */

	/**
	 * @class Address
	 * @brief A point of contact. So to speak.
	 */
	class Address {
		
        /**
         * @function constructor
         * @declaration function constructor( string mailbox, string host )
         * @brief Create a Mail.Address object from a given mailbox name and host
         * @param string mailbox The mailbox name e.g. user
         * @param string host The host name e.g. cention.se
         */
		function constructor( string mailbox, string host ){
			self.mailbox = mailbox;
			self.host = host;
		}
		/**
		 * @function constructor
		 * @declaration function constructor( string addr )
		 * @brief Create a Mail.Address object from a given email address
		 * @param string addr The email address
		 */
		function constructor( string addr ) {
			array hits;
			object result;
			object regex = new Regexp("(.*?)\@(.*)", "i");

			result = regex.match( addr );

			if( result ) {
				hits = result.captures();
				if( hits && hits[0] && hits[1] ) {
					self.mailbox = hits[0];
					self.host = hits[1];
					return;
				}
			}
			raise new Error("Invalid email address ($addr) passed to Mail.Address constructor");
		}

		/**
		 * @variable mailbox
		 * @type     string
		 * @brief    The name of the user for the mail box
		 */
		string mailbox;
		/**
		 * @variable host
		 * @type     string
		 * @brief    The email host
		 */
		string host;
		/**
		 * @variable name
		 * @type     string
		 * @brief    The real world name of the user. Please use .flatName() to access this value
		 */
		string name;
		
		/**
		 * @function flatName
		 * @declaration function flatName()
		 * @brief The name of the user. This function will make sure that the name is fixed and converted into plain text	
		 * @return The name of the user
		 */
		function flatName() {
			if( Mail.canDecodeISOString(.name) )
				return Mail.decodeISOString(.name);
			if( not .name.isUTF8() )
				return Mail.convertToDefaultEncodingFrom(.name, '');
			return .name;
		}
		/**
		 * @function flatAddress
		 * @declaration function flatAddress()
		 * @brief The combined email address as a string
		 * @return See the brief.
		 */
		function flatAddress() {
			string mailbox = (.mailbox.isUTF8() ? .mailbox : Mail.convertToDefaultEncodingFrom(.mailbox, ''));
			string host = (.host.isUTF8() ? .host : Mail.convertToDefaultEncodingFrom(.host, ''));
			return "${mailbox}@${host}";
		}

		function duplicate() {
			object o = new Mail.Address();
			o.mailbox = .mailbox;
			o.host = .host;
			o.name = .name;
			return o;
		}
		function checkEncoding() {
			.name = Mail.encodeISOString(.name);
		}
		function toString() {
			return "Mail.Address:${.flatName()} <${.flatAddress()}>";
		}
		
	}
	/**
	 * @end
	 */
	
	/**
	 * @class AddressList
	 * @brief A list of addresses
	 */
	class AddressList {
		/**
		 * @variable list
		 * @type     array
		 * @brief    The Mail.Address list
		 */
		array list;

		/**
		 * @function add
		 * @declaration function add(object address)
		 * @brief Add a Mail.Address object to the list
		 * @param object address The object to add
		 */
		function add(object address){
			Array.push( self.list, address );
		}
		/**
		 * @function flatAddresses
		 * @declaration function flatAddresses()
		 * @brief Get an array of string representing the flatAddress() of each Mail.Address object
		 * @description A description
		 * @return The return values
		 */
		function flatAddresses() {
			array list = [];
			.list.each() using ( address ) {
				list[] = address.flatAddress();
			};
			return list;
		}
		function duplicate() {
			object o = new Mail.AddressList();
			.list.each() using ( address ) {
				o.add( address.duplicate() );
			};
			return o;
		}
		function checkEncoding() {
			.list.each() using ( address ) {
				address.checkEncoding();
			};
		}
		
		function toString() {
			return "Mail.AddressList:${.list}";
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class MessageHeader
	 * @brief The header of a Mail.Message
	 */
	class MessageHeader {
		/**
		 * @variable return_path
		 * @type     Mail.AddressList
		 * @brief    An array containing a single Mail.Address that is the email's return path
		 */
		object return_path;
		/**
		 * @variable to
		 * @type     Mail.AddressList
		 * @brief    The list of people the email was/should be sent to.
		 */
		object to;
		/**
		 * @variable cc
		 * @type     Mail.AddressList
		 * @brief    The list of people the email was/should be CC'd to
		 */
		object cc;
		/**
		 * @variable bcc
		 * @type     Mail.AddressList
		 * @brief    The list of people the email should be BCC'd to
		 */
		object bcc;
		/**
		 * @variable reply_to
		 * @type     Mail.AddressList
		 * @brief    The list of people the email was/should be replied to
		 */
		object reply_to;
		/**
		 * @variable from
		 * @type     Mail.AddressList
		 * @brief    An array containing a single Mail.Address that the email is/was from
		 */
		object from;
		/**
		 * @variable sender
		 * @type     Mail.AddressList
		 * @brief    The sender list
		 */
		object sender;
		
		/**
		 * @variable ID
		 * @type     string
		 * @brief    The message ID (should be unique)
		 */
		string ID;
		/**
		 * @variable references
		 * @type     string
		 * @brief    One or more IDs separated by spaces this message references.
		 */
		string references;
		/**
		 * @variable in_reply_to
		 * @type     string
		 * @brief    The ID the email is in reply to. Allows the tracking of threads.
		 */
		string in_reply_to;
		/**
		 * @variable date
		 * @type     string
		 * @brief    The date the message was created
		 */
		string date;
		/**
		 * @variable recieved
		 * @type     string
		 * @brief    The date the message was received
		 */
		string recieved;
		/**
		 * @variable subject
		 * @type     string
		 * @brief    The message subject
		 */
		string subject;

		function constructor(){
			self.return_path = new Mail.AddressList();
			self.to = new Mail.AddressList();
			self.from = new Mail.AddressList();
			self.bcc = new Mail.AddressList();
			self.reply_to  = new Mail.AddressList();
			self.cc = new Mail.AddressList();
			self.sender = new Mail.AddressList();
		}
		function duplicate() {
			object o = new Mail.MessageHeader();
			o.return_path = .return_path.duplicate();
			o.from = .from.duplicate();
			o.sender = .sender.duplicate();
			o.to = .to.duplicate();
			o.cc = .cc.duplicate();
			o.bcc = .bcc.duplicate();
			o.reply_to = .reply_to.duplicate();
			o.ID = .ID;
			o.references = .references;
			o.in_reply_to = .in_reply_to;
			o.date = .date;
			o.recieved = .recieved;
			o.subject = .subject;
			return o;
		}
		function checkEncoding() {
			.return_path.checkEncoding();
			.from.checkEncoding();
			.sender.checkEncoding();
			.to.checkEncoding();
			.cc.checkEncoding();
			.bcc.checkEncoding();
			.reply_to.checkEncoding();
		}
	}
	/**
	 * @end
	 */

	/**
	 * @class MessageMultiPart
	 * @brief A multipart container for a email block
	 */
	class MessageMultiPart
	{
		array  parts;
		number nparts;
		number type;
		string subtype;
		
		function constructor(){
			self.type = Mail.Mime.TYPEMULTIPART;
		}
		
		/**
		 * @function isMultipart
		 * @declaration function isMultipart()
		 * @brief Check to see if the given block is a multipart block
		 * @return true if multipart, false otherwise.
		 */
		/**
		 * @function characterSet
		 * @declaration function characterSet()
		 * @brief Guess the character set of the tree of parts
		 * @return The character set, empty string otherwise
		 */
		/**
		 * @function toMessage
		 * @declaration function toMessage( boolean wantHTML )
		 * @brief Fetch all the parts below and including this part
		 * @param boolean wantHTML Whether html parts are required. true - only text/html is returned. false - only text/plain is returned.
		 * @param object attachmentDelivery A closure to invoke when an attachment object is found when generating the message.
		 * @return The message body
		 */
		/**
		 * @function attachmentList
		 * @declaration function attachmentList()
		 * @brief Fetch an array of Mail.MessagePart(s) that are attachments to the email
		 * @return An array of attachments.
		 */
		/**
		 * @function hasTextVersion
		 * @declaration function hasTextVersion()
		 * @brief Check to see if the part has a text/plain part(s) to it.
		 * @return true if there is a text/plain block, false otherwise
		 */
		/**
		 * @function hasHTMLVersion
		 * @declaration function hasHTMLVersion()
		 * @brief Check to see if the part has a text/html part(s) to it.
		 * @return true if there is a text/html block, false otherwise
		 */
		function isMultipart(){
			return true;
		}
		function characterSet() {
			string set = '';
			.parts.each() using ( part ) {
				set = part.characterSet();
				if( set )
					return false;
			};
			return set;
		}
		function toMessage( boolean wantHTML, object attachmentDelivery ) {
			return .parts.join('') using ( part ) {
				return part.toMessage( wantHTML, attachmentDelivery );
			};
		}
		function attachmentList() {
			array list = [];
			.parts.each() using ( part ) {
				array subList = part.attachmentList();
				subList.each() using ( subpart ) {
					list[] = subpart;
				};
			};
			return list;
		}
		
		function hasTextVersion() {
			boolean result = false;
			.parts.each() using ( part ) {
				if( part.hasTextVersion() ) {
					result = true;
					return false;
				}
			};
			return result;
		}
		function hasHTMLVersion() {
			boolean result = false;
			.parts.each() using ( part ) {
				if( part.hasHTMLVersion() ) {
					result = true;
					return false;
				}
			};
			return result;
		}
		/**
		 * @function addPart
		 * @declaration function addPart(object sub)
		 * @brief Add a Mail.MessagePart or Mail.MessageMultiPart to this block
		 * @param object sub The sub-part to add
		 */
		function addPart(object sub) {
			Array.push(self.parts,sub);
		}
		/**
		 * @function addAttachment
		 * @declaration function addAttachment(string path)
		 * @brief Add a given file as a part as an attachment
		 * @param string path The path to the file
		 */
		function addAttachment(string path){
			//Fixme check that file is readable
			object part = new Mail.MessagePart();
			part.filepath = path;
			part.filename = File.name(path);
			part.type = Mail.Mime.TYPEAPPLICATION;
			part.subtype = "octet-stream";
			part.encoding = Mail.Encoding.ENCBINARY;
			Array.push(self.parts, part);
		}
		/**
		 * @function embedImage
		 * @declaration function embedImage(string id, string path)
		 * @brief Add a given image as a part with an Content-ID that can be referenced
		 * @param string id The Content-ID the image should have
		 * @param string path The path to the image
		 */
		function embedImage( string id, string path ) {
			object part;
			string subtype;
			object match = Regexp.match('.*\.(.*)', path);
			if( match ) {
				switch( match.capture(0) ) {
					case 'jpeg':
					case 'jpg':
					case 'jpe':
						subtype = 'jpeg';
						break;
					case 'gif':
						subtype = 'gif';
						break;
					case 'tiff':
					case 'tif':
						subtype = 'tiff';
						break;
					case 'png':
						subtype = 'png';
						break;
					case 'bmp':
						subtype = 'x-ms-bmp';
						break;
				}
			}
			part = new Mail.MessagePart();
			part.ID = "<${id}>";
			part.filepath = path;
			part.filename = File.name(path);
			part.type = Mail.Mime.TYPEIMAGE;
			part.subtype = subtype;
			part.encoding = Mail.Encoding.ENCBINARY;
			Array.push(.parts, part);
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class MessagePart
	 * @brief An inidividual content part of an email block
	 */
	class MessagePart
	{
		string ID;
		number type;
		string subtype;
		number encoding;
		string content;
		string charset;
		string filename;
		string filepath;
		
		function constructor( ) {
			self.type = Mail.Mime.TYPETEXT;
			self.charset = 'UTF-8';
		}

		/**
		 * @function isMultipart
		 * @declaration function isMultipart()
		 * @brief Check to see if the given block is a multipart block
		 * @return true if multipart, false otherwise.
		 */
		/**
		 * @function characterSet
		 * @declaration function characterSet()
		 * @brief Guess the character set of the tree of parts
		 * @return The character set, empty string otherwise
		 */
		/**
		 * @function toMessage
		 * @declaration function toMessage( boolean wantHTML )
		 * @brief Fetch all the parts below and including this part
		 * @param boolean wantHTML Whether html parts are required. true - only text/html is returned. false - only text/plain is returned.
		 * @param object attachmentDelivery A closure to invoke when an attachment object is found when generating the message.
		 * @return The message body
		 */
		/**
		 * @function attachmentList
		 * @declaration function attachmentList()
		 * @brief Fetch an array of Mail.MessagePart(s) that are attachments to the email
		 * @return An array of attachments.
		 */
		/**
		 * @function hasTextVersion
		 * @declaration function hasTextVersion()
		 * @brief Check to see if the part has a text/plain part(s) to it.
		 * @return true if there is a text/plain block, false otherwise
		 */
		/**
		 * @function hasHTMLVersion
		 * @declaration function hasHTMLVersion()
		 * @brief Check to see if the part has a text/html part(s) to it.
		 * @return true if there is a text/html block, false otherwise
		 */		
		function isMultipart() {
			return false;
		}
		function characterSet() {
			return .charset;
		}
		/**
		 * @function regexpForAttachmentAnchors
		 * @declaration static function regexpForAttachmentAnchors { return new Regexp('attachment://([^/]*?)
		 * @brief A regular expression object that will match the attachment anchors provided when no attachment block was provided on a to-() function
		 * @return A regular expression object
		 * @static
		 */
		static function regexpForAttachmentAnchors {
			return new Regexp('attachment://([^/]*?)/type=([A-Za-z0-9-]+:[A-Za-z0-9-]+)/');
		}
		function toMessage( boolean wantHTML, object attachmentDelivery ) {
			if( .isAttachment() ) {
				if( attachmentDelivery )
					return attachmentDelivery.invoke( self );
			 	else
					return "";
			} else if( .type == Mail.Mime.TYPETEXT ) {
				string content = Mail.convertToDefaultEncodingFrom( .content, .charset );
				if( wantHTML and .subtype.toLower() == 'html' ) {
					return content;
				} else if( not wantHTML and .subtype.toLower() == 'plain' ) {
				    return content;
				}
			}
			return '';
		}
		
		function attachmentList() {
		 	if( .isAttachment() ) {
				return [ self ];
			}
			return [];
		}
		function hasTextVersion() {
			if( .type == Mail.Mime.TYPETEXT and .subtype.toLower() == 'plain' )
				return true;
			return false;
		}
		function hasHTMLVersion() {
			if( .type == Mail.Mime.TYPETEXT and .subtype.toLower() == 'html' )
				return true;
			return false;
		}
		/**
		 * @function isAttachment
		 * @declaration function isAttachment()
		 * @brief Check to see if the part is an attachment
		 * @return true if it is an attachment, false otherwise
		 */
		function isAttachment() {
			return (.filename != '');
		}
		/**
		 * @function fileName
		 * @declaration function fileName()
		 * @brief The filename if it is an attachment, post-processed to remove encoding
		 * @return The filename.
		 */
		function fileName() {
			if( .isAttachment() ) {
				string actual_name;
				if( Mail.canDecodeISOString(.filename) ) {
					actual_name = Mail.decodeISOString(.filename);
				} else {
					if( not .filename.isUTF8() ) {
						actual_name = Mail.convertToDefaultEncodingFrom(.filename, '');
					} else {
						actual_name = .filename;
					}
				}
				if( File.name(actual_name) ){
					actual_name = File.name(actual_name);
				}
				if( actual_name[0] == "." ) {
					actual_name = "unkwown$actual_name";
				}
				return actual_name;
			}
			return '';
		}
	}
	/**
	 * @end
	 */

	/**
	 * @class HTML
	 * @brief Class with static functions to help handle HTML emails
	 */
	class HTML {
		static array entities;
		static constructor {
			.entities = [
				'\#32'   => ' ', // space
				'\#33'   => '!', // exclamation mark
				'\#35'   => '#', // number sign
				'\#36'   => '$', // dollar sign
				'\#37'   => '%', // percent sign
				'\#40'   => '(', // left parenthesis
				'\#41'   => ')', // right parenthesis
				'\#42'   => '*', // asterisk
				'\#43'   => '+', // plus sign
				'\#44'   => ',', // comma
				'\#45'   => '-', // hyphen
				'\#46'   => '.', // period
				'\#47'   => '/', // slash
				'\#48'   => '0', // digit 0
				'\#49'   => '1', // digit 1
				'\#50'   => '2', // digit 2
				'\#51'   => '3', // digit 3
				'\#52'   => '4', // digit 4
				'\#53'   => '5', // digit 5
				'\#54'   => '6', // digit 6
				'\#55'   => '7', // digit 7
				'\#56'   => '8', // digit 8
				'\#57'   => '9', // digit 9
				'\#58'   => ':', // colon
				'\#59'   => ';', // semicolon
				'\#61'   => '=', // equals-to
				'\#63'   => '?', // question mark
				'\#64'   => '@', // at sign
				'\#65'   => 'A', // uppercase A
				'\#66'   => 'B', // uppercase B
				'\#67'   => 'C', // uppercase C
				'\#68'   => 'D', // uppercase D
				'\#69'   => 'E', // uppercase E
				'\#70'   => 'F', // uppercase F
				'\#71'   => 'G', // uppercase G
				'\#72'   => 'H', // uppercase H
				'\#73'   => 'I', // uppercase I
				'\#74'   => 'J', // uppercase J
				'\#75'   => 'K', // uppercase K
				'\#76'   => 'L', // uppercase L
				'\#77'   => 'M', // uppercase M
				'\#78'   => 'N', // uppercase N
				'\#79'   => 'O', // uppercase O
				'\#80'   => 'P', // uppercase P
				'\#81'   => 'Q', // uppercase Q
				'\#82'   => 'R', // uppercase R
				'\#83'   => 'S', // uppercase S
				'\#84'   => 'T', // uppercase T
				'\#85'   => 'U', // uppercase U
				'\#86'   => 'V', // uppercase V
				'\#87'   => 'W', // uppercase W
				'\#88'   => 'X', // uppercase X
				'\#89'   => 'Y', // uppercase Y
				'\#90'   => 'Z', // uppercase Z
				'\#91'   => '[', // left square bracket
				'\#92'   => "\\", // backslash
				'\#93'   => ']', // right square bracket
				'\#94'   => '^', // caret
				'\#95'   => '_', // underscore
				'\#96'   => '`', // grave accent
				'\#97'   => 'a', // lowercase a
				'\#98'   => 'b', // lowercase b
				'\#99'   => 'c', // lowercase c
				'\#100'  => 'd', // lowercase d
				'\#101'  => 'e', // lowercase e
				'\#102'  => 'f', // lowercase f
				'\#103'  => 'g', // lowercase g
				'\#104'  => 'h', // lowercase h
				'\#105'  => 'i', // lowercase i
				'\#106'  => 'j', // lowercase j
				'\#107'  => 'k', // lowercase k
				'\#108'  => 'l', // lowercase l
				'\#109'  => 'm', // lowercase m
				'\#110'  => 'n', // lowercase n
				'\#111'  => 'o', // lowercase o
				'\#112'  => 'p', // lowercase p
				'\#113'  => 'q', // lowercase q
				'\#114'  => 'r', // lowercase r
				'\#115'  => 's', // lowercase s
				'\#116'  => 't', // lowercase t
				'\#117'  => 'u', // lowercase u
				'\#118'  => 'v', // lowercase v
				'\#119'  => 'w', // lowercase w
				'\#120'  => 'x', // lowercase x
				'\#121'  => 'y', // lowercase y
				'\#122'  => 'z', // lowercase z
				'\#123'  => '{', // left curly brace
				'\#124'  => '|', // vertical bar
				'\#125'  => '}', // right curly brace
				'\#126'  => '~', // tilde
				'\#34'   => '"',  'quot'   => '"',  // quotation mark
				'\#39'   => '\'', 'apos'   => '\'', // apostrophe
				'\#38'   => '',   'amp'    => '&',  // ampersand
				'\#60'   => '<',  'lt'     => '<',  // less-than
				'\#62'   => '>',  'gt'     => '>',  // greater-than
				'\#160'  => ' ',  'nbsp'   => ' ',  // non-breaking space
				'\#161'  => '¡',  'iexcl'  => '¡',  // inverted exclamation mark
				'\#162'  => '¢',  'cent'   => '¢',  // cent
				'\#163'  => '£',  'pound'  => '£',  // pound
				'\#164'  => '¤',  'curren' => '¤',  // currency
				'\#165'  => '¥',  'yen'    => '¥',  // yen
				'\#166'  => '¦',  'brvbar' => '¦',  // broken vertical bar
				'\#167'  => '§',  'sect'   => '§',  // section
				'\#168'  => '¨',  'uml'    => '¨',  // spacing diaeresis
				'\#169'  => '©',  'copy'   => '©',  // copyright
				'\#170'  => 'ª',  'ordf'   => 'ª',  // feminine ordinal indicator
				'\#171'  => '«',  'laquo'  => '«',  // angle quotation mark (left)
				'\#172'  => '¬',  'not'    => '¬',  // negation
				'\#173'  => '­',   'shy'    => '­',   // soft hyphen
				'\#174'  => '®',  'reg'    => '®',  // registered trademark
				'\#175'  => '¯',  'macr'   => '¯',  // spacing macron
				'\#176'  => '°',  'deg'    => '°',  // degree
				'\#177'  => '±',  'plusmn' => '±',  // plus-or-minus
				'\#178'  => '²',  'sup2'   => '²',  // superscript 2
				'\#179'  => '³',  'sup3'   => '³',  // superscript 3
				'\#180'  => '´',  'acute'  => '´',  // spacing acute
				'\#181'  => 'µ',  'micro'  => 'µ',  // micro
				'\#182'  => '¶',  'para'   => '¶',  // paragraph
				'\#183'  => '·',  'middot' => '·',  // middle dot
				'\#184'  => '¸',  'cedil'  => '¸',  // spacing cedilla
				'\#185'  => '¹',  'sup1'   => '¹',  // superscript 1
				'\#186'  => 'º',  'ordm'   => 'º',  // masculine ordinal indicator
				'\#187'  => '»',  'raquo'  => '»',  // angle quotation mark (right)
				'\#188'  => '¼',  'frac14' => '¼',  // fraction 1/4
				'\#189'  => '½',  'frac12' => '½',  // fraction 1/2
				'\#190'  => '¾',  'frac34' => '¾',  // fraction 3/4
				'\#191'  => '¿',  'iquest' => '¿',  // inverted question mark
				'\#215'  => '×',  'times'  => '×',  // multiplication
				'\#247'  => '÷',  'divide' => '÷',  // division
				'\#192'  => 'À',  'Agrave' => 'À',  // capital a, grave accent
				'\#193'  => 'Á',  'Aacute' => 'Á',  // capital a, acute accent
				'\#194'  => 'Â',  'Acirc'  => 'Â',  // capital a, circumflex accent
				'\#195'  => 'Ã',  'Atilde' => 'Ã',  // capital a, tilde
				'\#196'  => 'Ä',  'Auml'   => 'Ä',  // capital a, umlaut mark
				'\#197'  => 'Å',  'Aring'  => 'Å',  // capital a, ring
				'\#198'  => 'Æ',  'AElig'  => 'Æ',  // capital ae
				'\#199'  => 'Ç',  'Ccedil' => 'Ç',  // capital c, cedilla
				'\#200'  => 'È',  'Egrave' => 'È',  // capital e, grave accent
				'\#201'  => 'É',  'Eacute' => 'É',  // capital e, acute accent
				'\#202'  => 'Ê',  'Ecirc'  => 'Ê',  // capital e, circumflex accent
				'\#203'  => 'Ë',  'Euml'   => 'Ë',  // capital e, umlaut mark
				'\#204'  => 'Ì',  'Igrave' => 'Ì',  // capital i, grave accent
				'\#205'  => 'Í',  'Iacute' => 'Í',  // capital i, acute accent
				'\#206'  => 'Î',  'Icirc'  => 'Î',  // capital i, circumflex accent
				'\#207'  => 'Ï',  'Iuml'   => 'Ï',  // capital i, umlaut mark
				'\#208'  => 'Ð',  'ETH'    => 'Ð',  // capital eth, Icelandic
				'\#209'  => 'Ñ',  'Ntilde' => 'Ñ',  // capital n, tilde
				'\#210'  => 'Ò',  'Ograve' => 'Ò',  // capital o, grave accent
				'\#211'  => 'Ó',  'Oacute' => 'Ó',  // capital o, acute accent
				'\#212'  => 'Ô',  'Ocirc'  => 'Ô',  // capital o, circumflex accent
				'\#213'  => 'Õ',  'Otilde' => 'Õ',  // capital o, tilde
				'\#214'  => 'Ö',  'Ouml'   => 'Ö',  // capital o, umlaut mark
				'\#216'  => 'Ø',  'Oslash' => 'Ø',  // capital o, slash
				'\#217'  => 'Ù',  'Ugrave' => 'Ù',  // capital u, grave accent
				'\#218'  => 'Ú',  'Uacute' => 'Ú',  // capital u, acute accent
				'\#219'  => 'Û',  'Ucirc'  => 'Û',  // capital u, circumflex accent
				'\#220'  => 'Ü',  'Uuml'   => 'Ü',  // capital u, umlaut mark
				'\#221'  => 'Ý',  'Yacute' => 'Ý',  // capital y, acute accent
				'\#222'  => 'Þ',  'THORN'  => 'Þ',  // capital THORN, Icelandic
				'\#223'  => 'ß',  'szlig'  => 'ß',  // small sharp s, German
				'\#224'  => 'à',  'agrave' => 'à',  // small a, grave accent
				'\#225'  => 'á',  'aacute' => 'á',  // small a, acute accent
				'\#226'  => 'â',  'acirc'  => 'â',  // small a, circumflex accent
				'\#227'  => 'ã',  'atilde' => 'ã',  // small a, tilde
				'\#228'  => 'ä',  'auml'   => 'ä',  // small a, umlaut mark
				'\#229'  => 'å',  'aring'  => 'å',  // small a, ring
				'\#230'  => 'æ',  'aelig'  => 'æ',  // small ae
				'\#231'  => 'ç',  'ccedil' => 'ç',  // small c, cedilla
				'\#232'  => 'è',  'egrave' => 'è',  // small e, grave accent
				'\#233'  => 'é',  'eacute' => 'é',  // small e, acute accent
				'\#234'  => 'ê',  'ecirc'  => 'ê',  // small e, circumflex accent
				'\#235'  => 'ë',  'euml'   => 'ë',  // small e, umlaut mark
				'\#236'  => 'ì',  'igrave' => 'ì',  // small i, grave accent
				'\#237'  => 'í',  'iacute' => 'í',  // small i, acute accent
				'\#238'  => 'î',  'icirc'  => 'î',  // small i, circumflex accent
				'\#239'  => 'ï',  'iuml'   => 'ï',  // small i, umlaut mark
				'\#240'  => 'ð',  'eth'    => 'ð',  // small eth, Icelandic
				'\#241'  => 'ñ',  'ntilde' => 'ñ',  // small n, tilde
				'\#242'  => 'ò',  'ograve' => 'ò',  // small o, grave accent
				'\#243'  => 'ó',  'oacute' => 'ó',  // small o, acute accent
				'\#244'  => 'ô',  'ocirc'  => 'ô',  // small o, circumflex accent
				'\#245'  => 'õ',  'otilde' => 'õ',  // small o, tilde
				'\#246'  => 'ö',  'ouml'   => 'ö',  // small o, umlaut mark
				'\#248'  => 'ø',  'oslash' => 'ø',  // small o, slash
				'\#249'  => 'ù',  'ugrave' => 'ù',  // small u, grave accent
				'\#250'  => 'ú',  'uacute' => 'ú',  // small u, acute accent
				'\#251'  => 'û',  'ucirc'  => 'û',  // small u, circumflex accent
				'\#252'  => 'ü',  'uuml'   => 'ü',  // small u, umlaut mark
				'\#253'  => 'ý',  'yacute' => 'ý',  // small y, acute accent
				'\#254'  => 'þ',  'thorn'  => 'þ',  // small thorn, Icelandic
				'\#255'  => 'ÿ',  'yuml'   => 'ÿ',  // small y, umlaut mark
				'\#8704' => '∀',  'forall' => '∀', // for all
				'\#8706' => '∂',  'part'   => '∂',  // part
				'\#8707' => '∃',  'exist'  => '∃',  // exists
				'\#8709' => '∅',  'empty'  => '∅',  // empty
				'\#8711' => '∇',  'nabla'  => '∇', // nabla
				'\#8712' => '∈',  'isin'   => '∈',  // isin
				'\#8713' => '∉',  'notin' => '∉', // notin
				'\#8715' => '∋',  'ni'    => '∋', // ni
				'\#8719' => '∏',  'prod'  => '∏',  // prod
				'\#8721' => '∑',  'sum'    => '∑', // sum
				'\#8722' => '−',  'minus'  => '−',  // minus
				'\#8727' => '∗',  'lowast' => '∗', // lowast
				'\#8730' => '√',  'radic'  => '√',  // square root
				'\#8733' => '∝',  'prop'   => '∝', // proportional to
				'\#8734' => '∞',  'infin'  => '∞',  // infinity
				'\#8736' => '∠',  'ang'   => '∠', // angle
				'\#8743' => '∧',  'and'    => '∧',  // and
				'\#8744' => '∨',  'or'     => '∨',  // or
				'\#8745' => '∩',  'cap'    => '∩',  // cap
				'\#8746' => '∪',  'cup'    => '∪',  // cup
				'\#8747' => '∫',  'int'    => '∫',  // integral
				'\#8756' => '∴',  'there4' => '∴', // therefore
				'\#8764' => '∼',  'sim'   => '∼', // similar to
				'\#8773' => '≅',  'cong'  => '≅', // congruent to
				'\#8776' => '≈',  'asymp'  => '≈',  // almost equal
				'\#8800' => '≠',  'ne'     => '≠',  // not equal
				'\#8801' => '≡',  'equiv'  => '≡',  // equivalent
				'\#8804' => '≤',  'le'     => '≤',  // less or equal
				'\#8805' => '≥',  'ge'     => '≥',  // greater or equal
				'\#8834' => '⊂',  'sub'   => '⊂', // subset of
				'\#8835' => '⊃',  'sup'   => '⊃', // superset of
				'\#8836' => '⊄',  'nsub'  => '⊄', // not subset of
				'\#8838' => '⊆',  'sube'  => '⊆', // subset or equal
				'\#8839' => '⊇',  'supe'  => '⊇', // superset or equal
				'\#8853' => '⊕',  'oplus' => '⊕', // circled plus
				'\#8855' => '⊗',  'otimes' => '⊗', // cirled times
				'\#8869' => '⊥',  'perp'  => '⊥', // perpendicular
				'\#8901' => '⋅',  'sdot'   => '⋅',  // dot operator
				'\#913'  => 'Α',  'Alpha'  => 'Α', // Alpha
				'\#914'  => 'Β',  'Beta'   => 'Β', // Beta
				'\#915'  => 'Γ',  'Gamma'  => 'Γ', // Gamma
				'\#916'  => 'Δ',  'Delta'  => 'Δ', // Delta
				'\#917'  => 'Ε',  'Epsilon' => 'Ε', // Epsilon
				'\#918'  => 'Ζ',  'Zeta'   => 'Ζ', // Zeta
				'\#919'  => 'Η',  'Eta'    => 'Η', // Eta
				'\#920'  => 'Θ',  'Theta'  => 'Θ', // Theta
				'\#921'  => 'Ι',  'Iota'   => 'Ι', // Iota
				'\#922'  => 'Κ',  'Kappa'  => 'Κ', // Kappa
				'\#923'  => 'Λ',  'Lambda' => 'Λ', // Lambda
				'\#924'  => 'Μ',  'Mu'     => 'Μ', // Mu
				'\#925'  => 'Ν',  'Nu'     => 'Ν', // Nu
				'\#926'  => 'Ξ',  'Xi'     => 'Ξ', // Xi
				'\#927'  => 'Ο',  'Omicron' => 'Ο', // Omicron
				'\#928'  => 'Π',  'Pi'     => 'Π', // Pi
				'\#929'  => 'Ρ',  'Rho'    => 'Ρ', // Rho
				'\#931'  => 'Σ',  'Sigma'  => 'Σ', // Sigma
				'\#932'  => 'Τ',  'Tau'    => 'Τ', // Tau
				'\#933'  => 'Υ',  'Upsilon' => 'Υ', // Upsilon
				'\#934'  => 'Φ',  'Phi'    => 'Φ', // Phi
				'\#935'  => 'Χ',  'Chi'    => 'Χ', // Chi
				'\#936'  => 'Ψ',  'Psi'    => 'Ψ', // Psi
				'\#937'  => 'Ω',  'Omega'  => 'Ω', // Omega
				'\#945'  => 'α',  'alpha'  => 'α', // alpha
				'\#946'  => 'β',  'beta'   => 'β', // beta
				'\#947'  => 'γ',  'gamma'  => 'γ', // gamma
				'\#948'  => 'δ',  'delta'  => 'δ', // delta
				'\#949'  => 'ε',  'epsilon' => 'ε', // epsilon
				'\#950'  => 'ζ',  'zeta'   => 'ζ', // zeta
				'\#951'  => 'η',  'eta'    => 'η', // eta
				'\#952'  => 'θ',  'theta'  => 'θ', // theta
				'\#953'  => 'ι',  'iota'   => 'ι', // iota
				'\#954'  => 'κ',  'kappa'  => 'κ', // kappa
				'\#955'  => 'λ',  'lambda' => 'λ', // lambda
				'\#956'  => 'μ',  'mu'     => 'μ', // mu
				'\#957'  => 'ν',  'nu'     => 'ν', // nu
				'\#958'  => 'ξ',  'xi'     => 'ξ', // xi
				'\#959'  => 'ο',  'omicron' => 'ο', // omicron
				'\#960'  => 'π',  'pi'     => 'π', // pi
				'\#961'  => 'ρ',  'rho'    => 'ρ', // rho
				'\#962'  => 'ς',  'sigmaf' => 'ς', // sigmaf
				'\#963'  => 'σ',  'sigma'  => 'σ', // sigma
				'\#964'  => 'τ',  'tau'    => 'τ', // tau
				'\#965'  => 'υ',  'upsilon' => 'υ', // upsilon
				'\#966'  => 'φ',  'phi'    => 'φ', // phi
				'\#967'  => 'χ',  'chi'    => 'χ', // chi
				'\#968'  => 'ψ',  'psi'    => 'ψ', // psi
				'\#969'  => 'ω',  'omega'  => 'ω', // omega
				'\#977'  => 'ϑ',  'thetasym' => 'ϑ', // theta symbol
				'\#978'  => 'ϒ',  'upsih'  => 'ϒ', // upsilon symbol
				'\#982'  => 'ϖ',  'piv'    => 'ϖ', // pi symbol
				'\#338'  => 'Œ',  'OElig'   => 'Œ', // capital ligature OE
				'\#339'  => 'œ',  'oelig'   => 'œ', // small ligature oe
				'\#352'  => 'Š',  'Scaron'  => 'Š', // capital S with caron
				'\#353'  => 'š',  'scaron'  => 'š', // small S with caron
				'\#376'  => 'Ÿ',  'Yuml'    => 'Ÿ', // capital Y with diaeres
				'\#402'  => 'ƒ',  'fnof'    => 'ƒ', // f with hook
				'\#710'  => 'ˆ',  'circ'    => 'ˆ', // modifier letter circumflex accent
				'\#732'  => '˜',  'tilde'   => '˜', // small tilde
				'\#8194' => ' ',  'ensp'    => ' ', // en space
				'\#8195' => ' ',  'emsp'    => ' ', // em space
				'\#8201' => ' ',  'thinsp'  => ' ', // thin space
				'\#8204' => '‌',   'zwnj'    => '‌', // zero width non-joiner
				'\#8205' => '‍',   'zwj'     => '‍', // zero width joiner
				'\#8211' => '–',  'ndash'   => '–', // en dash
				'\#8212' => '—',  'mdash'   => '—', // em dash
				'\#8216' => '‘',  'lsquo'   => '‘', // left single quotation mark
				'\#8217' => '’',  'rsquo'   => '’', // right single quotation mark
				'\#8218' => '‚',  'sbquo'   => '‚', // single low-9 quotation mark
				'\#8220' => '“',  'ldquo'   => '“', // left double quotation mark
				'\#8221' => '”',  'rdquo'   => '”', // right double quotation mark
				'\#8222' => '„',  'bdquo'   => '„', // double low-9 quotation mark
				'\#8224' => '†',  'dagger'  => '†', // dagger
				'\#8225' => '‡',  'Dagger'  => '‡', // double dagger
				'\#8226' => '•',  'bull'    => '•', // bullet
				'\#8230' => '…',  'hellip'  => '…', // horizontal ellipsis
				'\#8240' => '‰',  'permil'  => '‰', // per mille
				'\#8242' => '′',  'prime'   => '′', // minutes
				'\#8243' => '″',  'Prime'   => '″', // seconds
				'\#8249' => '‹',  'lsaquo'  => '‹', // single left angle quotation
				'\#8250' => '›',  'rsaquo'  => '›', // single right angle quotation
				'\#8254' => '‾',  'oline'   => '‾', // overline
				'\#8364' => '€',  'euro'    => '€', // euro
				'\#8482' => '™',  'trade'   => '™', // trademark
				'\#8592' => '←',  'larr'    => '←', // left arrow
				'\#8593' => '↑',  'uarr'    => '↑', // up arrow
				'\#8594' => '→',  'rarr'    => '→', // right arrow
				'\#8595' => '↓',  'darr'    => '↓', // down arrow
				'\#8596' => '↔',  'harr'    => '↔', // left right arrow
				'\#8629' => '↵',  'crarr'   => '↵', // carriage return arrow
				'\#8968' => '⌈',  'lceil'   => '⌈', // left ceiling
				'\#8969' => '⌉',  'rceil'   => '⌉', // right ceiling
				'\#8970' => '⌊',  'lfloor'  => '⌊', // left floor
				'\#8971' => '⌋',  'rfloor'  => '⌋', // right floor
				'\#9674' => '◊',  'loz'     => '◊', // lozenge
				'\#9824' => '♠',  'spades'  => '♠', // spade
				'\#9827' => '♣',  'clubs'   => '♣', // club
				'\#9829' => '♥',  'hearts'  => '♥', // heart
				'\#9830' => '♦',  'diams'   => '♦' // diamond
			];
		}
		/**
		 * @function stripHTML
		 * @static
		 * @declaration static function stripHTML( string html )
		 * @brief Strip the HTML from a given string
		 * @description This function will convert various entities to plain text versions, remove tags and replaces line breaks with new lines.
		 * @param string html The string to strip
		 * @return A stripped string
		 */
		static function stripHTML( string html ) {
			string result = .stripTags(html);
			for( number i = 0; i < .entities.size(); i++ ) {
				object regex = new Regexp("(&" + .entities.getName(i) + ";)", "igx");
				result = regex.replaceAll(result, .entities[i]);
			}
			return result;
		}

		static function stripTags( string html ) {
			string emailAddress = '(([A-Za-z0-9]+)\.?)+@(([A-Za-z0-9]+)\.?)+';
			object capture_email = new Regexp("<($emailAddress)>");
			object strip_title_tag = new Regexp('<title>.*?</title>', 'si');
			object strip_style_tag = new Regexp('<style.*?>.*?</style>', 'si');
			object strip_comment = new Regexp("<!--.*?-->", 's');
			object strip_tag = new Regexp("</?.*?>", 's');
			object compress_whitespace = new Regexp('[ \t]+');
			object br_replace = new Regexp("<br */?>", "gi");
			object p_replace = new Regexp("</p>", "gi");
			object div_replace = new Regexp("</div>", "gi");
			object h_replace = new Regexp("</h[1-9]>", "gi");
			object tr_replace = new Regexp("</tr>", "gi");

			html = Regexp.replaceAll("\r\n|\r|\n", html, '');
			html = strip_comment.replaceAll(html, ' ');
			html = br_replace.replaceAll(html, "\n");
			html = div_replace.replaceAll(html, "\n");
			html = p_replace.replaceAll(html, "\n");
			html = h_replace.replaceAll(html, "\n");
			html = tr_replace.replaceAll(html, "\n");
			html = capture_email.replaceAll(html, '\1');
			html = strip_title_tag.replaceAll(html, ' ');
			html = strip_style_tag.replaceAll(html, ' ');
			html = strip_tag.replaceAll(html, ' ');
			html = compress_whitespace.replaceAll(html, ' ');
			html = String.trim(html, "\r\n\t ");

			return html;
		}
	}
	/**
	 * @end
	 */
}
/**
 * @end
 */

uses "cmime";

Mail.defaultEncodingTargetVariants = [ 'UTF-8', 'UTF8' ];
Mail.registerOutput( closure(number type, string value) {
	if( type >= Mail.OUTPUT_NORMAL ) {
		Console.println("[mail-module.${Mail.outputTypeToString(type)}] $value");
	}
});
